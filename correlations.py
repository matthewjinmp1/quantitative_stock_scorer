"""
Calculate correlation between ROA/EBIT-PPE and forward return by period
For each period, calculate correlation across all stocks
Reads data from metrics.json (generated by metrics.py)
"""
import json
import numpy as np
from scipy.stats import pearsonr, spearmanr, rankdata
from typing import List, Tuple
import matplotlib.pyplot as plt

def load_data(filename: str = "metrics.json") -> List[dict]:
    """
    Load stock data from JSON file (metrics.json)
    
    Args:
        filename: Path to JSON file (default: metrics.json)
        
    Returns:
        List of stock data dictionaries
    """
    try:
        with open(filename, 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        print(f"Error: {filename} not found")
        return []
    except json.JSONDecodeError:
        print(f"Error: Invalid JSON in {filename}")
        return []

def extract_data_by_period_and_forward_return(data: List[dict], metric_keys: List[str] = None) -> dict:
    """
    Extract metrics and forward return data grouped by time period AND forward return period
    Structure: {forward_return_period: {time_period: {metric_key: [values], 'forward_return': [values]}}}
    
    Args:
        data: List of stock data dictionaries
        metric_keys: List of metric keys to extract (if None, auto-detect from data)
        
    Returns:
        Dictionary: {forward_return_period: {time_period: {metric_key: [values], 'forward_return': [values]}}}
    """
    # Forward return periods to analyze (including total forward return)
    forward_return_periods = ['total', '1y', '3y', '5y', '10y']
    
    # Structure: {forward_return_period: {time_period: {metric_key: [values], 'forward_return': [values]}}}
    forward_return_data = {period: {} for period in forward_return_periods}
    
    # Auto-detect metric keys if not provided
    if metric_keys is None:
        metric_keys = []
        for stock in data:
            for entry in stock.get("data", []):
                # Find all numeric metrics (excluding period, price, dividends, total_return, forward_return)
                excluded_keys = {'period', 'price', 'dividends', 'total_return', 'forward_return', 
                                'forward_return_1y', 'forward_return_3y', 'forward_return_5y', 'forward_return_10y'}
                for key, value in entry.items():
                    if key not in excluded_keys and value is not None and isinstance(value, (int, float)):
                        if key not in metric_keys:
                            metric_keys.append(key)
                break  # Only need to check one entry
    
    # Extract data grouped by time period and forward return period
    for stock in data:
        symbol = stock.get("symbol", "Unknown")
        for entry in stock.get("data", []):
            time_period = entry.get("period")
            
            # Skip invalid periods
            if time_period is None or time_period == 0:
                continue
            
            # For each forward return period
            for forward_period in forward_return_periods:
                # Handle total forward return separately (it's just 'forward_return', not 'forward_return_total')
                if forward_period == 'total':
                    forward_return_key = "forward_return"
                else:
                    forward_return_key = f"forward_return_{forward_period}"
                forward_return_value = entry.get(forward_return_key)
                
                # Initialize time period if not exists
                if time_period not in forward_return_data[forward_period]:
                    forward_return_data[forward_period][time_period] = {}
                    for metric_key in metric_keys:
                        forward_return_data[forward_period][time_period][metric_key] = []
                        forward_return_data[forward_period][time_period][f'forward_return_{metric_key}'] = []
                
                # For each metric
                for metric_key in metric_keys:
                    metric_value = entry.get(metric_key)
                    
                    # Add valid data points (both metric and forward return must be valid)
                    if (metric_value is not None and forward_return_value is not None and 
                        isinstance(metric_value, (int, float)) and isinstance(forward_return_value, (int, float))):
                        forward_return_data[forward_period][time_period][metric_key].append(float(metric_value))
                        forward_return_data[forward_period][time_period][f'forward_return_{metric_key}'].append(float(forward_return_value))
    
    return forward_return_data

def calculate_correlations(metric_values: List[float], forward_return_values: List[float]) -> dict:
    """
    Calculate correlation statistics between a metric and forward return
    
    Args:
        metric_values: List of metric values (e.g., ROA or EBIT/PPE)
        forward_return_values: List of forward return values
        
    Returns:
        Dictionary with correlation statistics
    """
    
    if len(metric_values) < 2:
        return {
            "n_pairs": len(metric_values),
            "pearson_correlation": None,
            "pearson_pvalue": None,
            "ranked_correlation": None,
            "ranked_pvalue": None,
            "spearman_correlation": None,
            "spearman_pvalue": None,
            "error": "Insufficient data points for correlation"
        }
    
    # Convert to numpy arrays
    metric_array = np.array(metric_values)
    forward_return_array = np.array(forward_return_values)
    
    # Rank the data before correlating
    # Rankdata assigns ranks from 1 to n (where n = number of data points)
    # Average ranks are used for tied values
    metric_ranks = rankdata(metric_array, method='average')
    forward_return_ranks = rankdata(forward_return_array, method='average')
    
    # Calculate Pearson correlation on original values (linear relationship)
    pearson_corr, pearson_p = pearsonr(metric_array, forward_return_array)
    
    # Calculate correlation on ranked data (this is equivalent to Spearman)
    ranked_corr, ranked_p = pearsonr(metric_ranks, forward_return_ranks)
    
    # Also calculate Spearman for verification (should match ranked correlation)
    spearman_corr, spearman_p = spearmanr(metric_array, forward_return_array)
    
    # Calculate basic statistics
    metric_mean = np.mean(metric_array)
    metric_std = np.std(metric_array)
    forward_return_mean = np.mean(forward_return_array)
    forward_return_std = np.std(forward_return_array)
    
    return {
        "n_pairs": len(metric_values),
        "pearson_correlation": float(pearson_corr),
        "pearson_pvalue": float(pearson_p),
        "ranked_correlation": float(ranked_corr),
        "ranked_pvalue": float(ranked_p),
        "spearman_correlation": float(spearman_corr),
        "spearman_pvalue": float(spearman_p),
        "metric_mean": float(metric_mean),
        "metric_std": float(metric_std),
        "metric_min": float(np.min(metric_array)),
        "metric_max": float(np.max(metric_array)),
        "forward_return_mean": float(forward_return_mean),
        "forward_return_std": float(forward_return_std),
        "forward_return_min": float(np.min(forward_return_array)),
        "forward_return_max": float(np.max(forward_return_array))
    }

def print_statistics(stats: dict):
    """
    Print correlation statistics in a readable format
    
    Args:
        stats: Dictionary with correlation statistics
    """
    print("\n" + "="*80)
    print("ROA vs Forward Return Correlation Analysis")
    print("="*80)
    print(f"\nNumber of data points: {stats['n_pairs']:,}")
    print(f"\nROA Statistics:")
    print(f"  Mean: {stats['roa_mean']:.4f}")
    print(f"  Std Dev: {stats['roa_std']:.4f}")
    print(f"  Min: {stats['roa_min']:.4f}")
    print(f"  Max: {stats['roa_max']:.4f}")
    print(f"\nForward Return Statistics:")
    print(f"  Mean: {stats['forward_return_mean']:.2f}%")
    print(f"  Std Dev: {stats['forward_return_std']:.2f}%")
    print(f"  Min: {stats['forward_return_min']:.2f}%")
    print(f"  Max: {stats['forward_return_max']:.2f}%")
    print(f"\nCorrelation Results:")
    print(f"  Pearson Correlation (on original values): {stats['pearson_correlation']:.4f}")
    print(f"  Pearson p-value: {stats['pearson_pvalue']:.4e}")
    if stats['pearson_pvalue'] < 0.05:
        print(f"    -> Statistically significant (p < 0.05)")
    else:
        print(f"    -> Not statistically significant (p >= 0.05)")
    print(f"\n  Ranked Correlation (on ranked values): {stats['ranked_correlation']:.4f}")
    print(f"  Ranked p-value: {stats['ranked_pvalue']:.4e}")
    if stats['ranked_pvalue'] < 0.05:
        print(f"    -> Statistically significant (p < 0.05)")
    else:
        print(f"    -> Not statistically significant (p >= 0.05)")
    print(f"\n  Spearman Correlation (for verification): {stats['spearman_correlation']:.4f}")
    print(f"  Spearman p-value: {stats['spearman_pvalue']:.4e}")
    print(f"    -> Note: Ranked correlation should match Spearman correlation")
    print("\n" + "="*80)

def plot_ranks(roa_ranks: List[float], forward_return_ranks: List[float], 
               stats: dict, output_file: str = "roa_forward_return_ranks.png"):
    """
    Create a scatter plot of ranked ROA vs ranked forward return
    
    Args:
        roa_ranks: List of ROA ranks (1 to n)
        forward_return_ranks: List of forward return ranks (1 to n)
        stats: Dictionary with correlation statistics
        output_file: Output filename for the plot
    """
    plt.figure(figsize=(12, 8))
    
    # Create scatter plot
    plt.scatter(roa_ranks, forward_return_ranks, alpha=0.5, s=20)
    
    # Add labels and title
    plt.xlabel('ROA Rank (1 = lowest, ' + str(stats['n_pairs']) + ' = highest)', fontsize=12)
    plt.ylabel('Forward Return Rank (1 = lowest, ' + str(stats['n_pairs']) + ' = highest)', fontsize=12)
    plt.title('Ranked ROA vs Ranked Forward Return\n(All Stocks, All Periods)', fontsize=14, fontweight='bold')
    
    # Add correlation statistics as text
    stats_text = f"Ranked Correlation: {stats['ranked_correlation']:.4f}\n"
    stats_text += f"p-value: {stats['ranked_pvalue']:.4e}\n"
    stats_text += f"Number of data points: {stats['n_pairs']:,}\n"
    stats_text += f"Ranks range from 1 to {stats['n_pairs']}"
    
    plt.text(0.05, 0.95, stats_text, transform=plt.gca().transAxes,
             fontsize=10, verticalalignment='top',
             bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5))
    
    # Add diagonal reference line (perfect correlation would follow this)
    max_rank = stats['n_pairs']
    plt.plot([1, max_rank], [1, max_rank], 'r--', alpha=0.3, label='Perfect Correlation')
    plt.legend()
    
    # Set equal aspect ratio and limits
    plt.xlim(0, max_rank + 50)
    plt.ylim(0, max_rank + 50)
    plt.gca().set_aspect('equal', adjustable='box')
    
    # Add grid
    plt.grid(True, alpha=0.3)
    
    # Tight layout
    plt.tight_layout()
    
    # Save plot
    plt.savefig(output_file, dpi=300, bbox_inches='tight')
    print(f"\nPlot saved to {output_file}")
    
    # Show plot
    plt.show()

def detect_available_metrics(data: List[dict]) -> dict:
    """
    Detect which metrics are available in the data
    
    Args:
        data: List of stock data dictionaries
    
    Returns:
        Dictionary mapping metric keys to their display names and descriptions
    """
    available_metrics = {}
    metric_display_names = {
        'roa': 'ROA (Return on Assets)',
        'ebit_ppe': 'EBIT/PPE (EBIT per Property, Plant & Equipment)',
        'ebit_ppe_ttm': 'EBIT/PPE TTM (Trailing Twelve Months)'
    }
    
    # Check which metrics exist in the data by scanning all entries
    # Exclude non-metric keys
    excluded_keys = {'period', 'price', 'dividends', 'total_return', 'forward_return'}
    
    # First, find all potential metric keys by scanning all entries
    all_metric_keys = set()
    for stock in data:
        for entry in stock.get("data", []):
            for key, value in entry.items():
                if key not in excluded_keys:
                    # Check if it's a numeric value (could be a metric)
                    if value is not None and isinstance(value, (int, float)):
                        all_metric_keys.add(key)
    
    # Now check which of these have display names, or create default names
    for metric_key in sorted(all_metric_keys):
        if metric_key in metric_display_names:
            # Use the predefined display name
            available_metrics[metric_key] = metric_display_names[metric_key]
        else:
            # Create a default display name from the key
            # Convert snake_case to Title Case
            display_name = metric_key.replace('_', ' ').title()
            available_metrics[metric_key] = display_name
    
    return available_metrics

def get_metric_selection(available_metrics: dict) -> str:
    """
    Display a dynamic menu and get user's metric selection
    
    Args:
        available_metrics: Dictionary mapping metric keys to display names
    
    Returns:
        String indicating selected metric(s) or 'exit'
    """
    print("\n" + "="*80)
    print("Correlation Analysis - Metric Selection")
    print("="*80)
    print("\nSelect which metric to analyze:")
    
    # Build menu dynamically based on available metrics
    menu_items = []
    metric_keys = sorted(available_metrics.keys())  # Sort for consistent ordering
    
    # Add individual metrics
    for i, metric_key in enumerate(metric_keys, start=1):
        menu_items.append((str(i), metric_key, available_metrics[metric_key]))
        print(f"  {i}. {available_metrics[metric_key]}")
    
    # Add "All metrics" option if more than one metric
    if len(metric_keys) > 1:
        menu_items.append((str(len(metric_keys) + 1), 'all', 'All metrics'))
        print(f"  {len(metric_keys) + 1}. All metrics")
    
    # Add exit option
    exit_num = len(metric_keys) + (2 if len(metric_keys) > 1 else 1)
    menu_items.append((str(exit_num), 'exit', 'Exit'))
    print(f"  {exit_num}. Exit")
    
    print("="*80)
    
    max_choice = exit_num
    while True:
        try:
            choice = input(f"\nEnter your choice (1-{max_choice}): ").strip()
            
            # Find the menu item for this choice
            for num, key, _ in menu_items:
                if choice == num:
                    return key
            
            print(f"Invalid choice. Please enter a number between 1 and {max_choice}.")
        except KeyboardInterrupt:
            print("\n\nExiting...")
            return 'exit'
        except Exception as e:
            print(f"Error: {e}. Please try again.")

def print_correlations_by_forward_period(results: dict, metric_name: str):
    """
    Print correlation for each forward return period (1y, 3y, 5y, 10y) for a given metric
    
    Args:
        results: Dictionary mapping forward_return_period -> correlation results dict
        metric_name: Display name of the metric
    """
    print("\n" + "="*100)
    print(f"{metric_name} vs Forward Return Correlation by Forward Return Period")
    print("(Weighted average of correlations across all time periods)")
    print("="*100)
    print(f"\n{'Forward Period':<20} {'Correlation':<15} {'p-value':<15} {'Significant':<15} {'N Pairs':<15} {'N Periods':<15}")
    print("-" * 100)
    
    # Display in order: total, 1y, 3y, 5y, 10y
    forward_periods = ['total', '1y', '3y', '5y', '10y']
    
    for forward_period in forward_periods:
        if forward_period in results:
            result = results[forward_period]
            ranked_corr = result.get('ranked_correlation')
            p_value = result.get('ranked_pvalue')
            n_pairs = result.get('n_pairs', 0)
            n_periods = result.get('n_periods', 0)
            
            if ranked_corr is not None and p_value is not None:
                is_significant = p_value < 0.05
                significance = "Yes" if is_significant else "No"
                if forward_period == 'total':
                    period_display = "Total forward return"
                else:
                    period_display = f"{forward_period} forward return"
                print(f"{period_display:<20} {ranked_corr:<15.4f} {p_value:<15.4e} {significance:<15} {n_pairs:<15} {n_periods:<15}")
            else:
                if forward_period == 'total':
                    period_display = "Total forward return"
                else:
                    period_display = f"{forward_period} forward return"
                print(f"{period_display:<20} {'N/A':<15} {'N/A':<15} {'N/A':<15} {n_pairs:<15} {n_periods:<15}")
    
    print("="*100)


def print_forward_period_correlations_summary(results: dict, metric_name: str):
    """
    Print summary statistics for correlation results across forward return periods for a given metric
    
    Args:
        results: Dictionary mapping forward_return_period -> correlation results dict
        metric_name: Display name of the metric
    """
    if not results:
        return
    
    print("\n" + "="*100)
    print(f"{metric_name} vs Forward Return Correlation Summary")
    print("="*100)
    
    forward_periods = ['total', '1y', '3y', '5y', '10y']
    significant_count = 0
    correlations = []
    weights = []  # Number of data points for each forward return period (for weighting)
    
    for forward_period in forward_periods:
        if forward_period in results:
            result = results[forward_period]
            ranked_corr = result.get('ranked_correlation')
            p_value = result.get('ranked_pvalue')
            is_significant = p_value < 0.05 if p_value is not None else False
            
            if is_significant:
                significant_count += 1
            if ranked_corr is not None:
                correlations.append(ranked_corr)
                weights.append(result.get('n_pairs', 0))  # Use number of data points as weight
    
    print("\nSummary Statistics Across Forward Return Periods:")
    print(f"  Total forward return periods analyzed: {len([p for p in forward_periods if p in results])}")
    print(f"  Periods with significant correlation (p < 0.05): {significant_count}")
    if correlations:
        # Calculate weighted average correlation (weighted by number of data points)
        correlations_array = np.array(correlations)
        weights_array = np.array(weights)
        weighted_avg = np.average(correlations_array, weights=weights_array)
        
        print(f"  Average ranked correlation (unweighted): {np.mean(correlations):.4f}")
        print(f"  Weighted average ranked correlation (by data points): {weighted_avg:.4f}")
        print(f"  Median ranked correlation: {np.median(correlations):.4f}")
        print(f"  Min ranked correlation: {np.min(correlations):.4f}")
        print(f"  Max ranked correlation: {np.max(correlations):.4f}")
    print("="*100)


def main():
    """
    Main function to calculate and display correlation analysis by period
    """
    # Load data first to detect available metrics
    print("Loading data from metrics.json...")
    data = load_data("metrics.json")
    
    if not data:
        print("No data loaded. Exiting.")
        return
    
    print(f"Loaded data for {len(data)} stock(s)")
    
    # Detect available metrics
    available_metrics = detect_available_metrics(data)
    
    if not available_metrics:
        print("No metrics found in data. Exiting.")
        return
    
    # Get user's metric selection
    selected_metrics = get_metric_selection(available_metrics)
    
    if selected_metrics == 'exit':
        print("Exiting program.")
        return
    
    # Determine which metrics to process
    if selected_metrics == 'all':
        metric_keys_to_process = list(available_metrics.keys())
    else:
        metric_keys_to_process = [selected_metrics]
    
    # Extract data grouped by time period AND forward return period
    print(f"\nExtracting metrics and forward return data by time period and forward return period...")
    forward_return_data = extract_data_by_period_and_forward_return(data, metric_keys_to_process)
    
    if not forward_return_data:
        print("No valid forward return data found. Exiting.")
        return
    
    # Calculate correlations: for each forward return period and metric,
    # calculate correlations for each time period, then take weighted average
    print("\nCalculating correlations for each time period, then weighted average across periods...")
    all_results = {metric_key: {} for metric_key in metric_keys_to_process}
    
    forward_return_periods = ['total', '1y', '3y', '5y', '10y']
    
    for forward_period in forward_return_periods:
        for metric_key in metric_keys_to_process:
            # Calculate correlations for each time period
            period_correlations = []
            period_weights = []  # Sample sizes for weighting
            period_stats = []  # Store full stats for each period
            
            # Get all time periods for this forward return period
            time_periods = sorted([p for p in forward_return_data[forward_period].keys() 
                                   if isinstance(p, str) or (isinstance(p, (int, float)) and p != 0)])
            
            for time_period in time_periods:
                period_data = forward_return_data[forward_period][time_period]
                metric_values = period_data.get(metric_key, [])
                forward_return_values = period_data.get(f"forward_return_{metric_key}", [])
                
                # Calculate correlation for this time period
                if len(metric_values) >= 2 and len(metric_values) == len(forward_return_values):
                    period_stat = calculate_correlations(metric_values, forward_return_values)
                    ranked_corr = period_stat.get('ranked_correlation')
                    
                    if ranked_corr is not None:
                        period_correlations.append(ranked_corr)
                        period_weights.append(period_stat.get('n_pairs', 0))
                        period_stat['time_period'] = time_period
                        period_stats.append(period_stat)
            
            # Calculate weighted average correlation across all time periods
            if period_correlations and period_weights:
                correlations_array = np.array(period_correlations)
                weights_array = np.array(period_weights)
                weighted_avg_correlation = np.average(correlations_array, weights=weights_array)
                
                # Calculate weighted average p-value (using Fisher's z-transformation would be more accurate,
                # but for simplicity we'll use weighted average of p-values)
                period_pvalues = [s.get('ranked_pvalue') for s in period_stats if s.get('ranked_pvalue') is not None]
                if period_pvalues:
                    # Weight p-values by sample size (inverse weighting - larger samples get more weight)
                    pvalues_array = np.array(period_pvalues)
                    weighted_avg_pvalue = np.average(pvalues_array, weights=weights_array)
                else:
                    weighted_avg_pvalue = None
                
                # Total number of pairs across all periods
                total_pairs = sum(period_weights)
                
                # Create summary stats
                stats = {
                    'forward_period': forward_period,
                    'metric_key': metric_key,
                    'ranked_correlation': float(weighted_avg_correlation),
                    'ranked_pvalue': float(weighted_avg_pvalue) if weighted_avg_pvalue is not None else None,
                    'n_pairs': total_pairs,
                    'n_periods': len(period_correlations),
                    'period_correlations': period_correlations,  # Store for reference
                    'period_stats': period_stats  # Store full period stats
                }
                
                all_results[metric_key][forward_period] = stats
    
    # Display results for each selected metric
    for metric_key in metric_keys_to_process:
        results = all_results[metric_key]
        if results:
            metric_name = available_metrics.get(metric_key, metric_key)
            print_correlations_by_forward_period(results, metric_name)
    
    # Print summary statistics for each selected metric
    for metric_key in metric_keys_to_process:
        results = all_results[metric_key]
        if results:
            metric_name = available_metrics.get(metric_key, metric_key)
            print_forward_period_correlations_summary(results, metric_name)

if __name__ == "__main__":
    main()

