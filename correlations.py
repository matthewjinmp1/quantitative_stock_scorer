"""
Calculate correlation between ROA/EBIT-PPE and forward return by period
For each period, calculate correlation across all stocks
Reads data from metrics.json (generated by metrics.py)
"""
import json
import numpy as np
from scipy.stats import pearsonr, spearmanr, rankdata
from typing import List, Tuple
import matplotlib.pyplot as plt

def load_data(filename: str = "metrics.json") -> List[dict]:
    """
    Load stock data from JSON file (metrics.json)
    
    Args:
        filename: Path to JSON file (default: metrics.json)
        
    Returns:
        List of stock data dictionaries
    """
    try:
        with open(filename, 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        print(f"Error: {filename} not found")
        return []
    except json.JSONDecodeError:
        print(f"Error: Invalid JSON in {filename}")
        return []

def extract_data_by_period(data: List[dict]) -> dict:
    """
    Extract ROA, EBIT/PPE, and forward return data grouped by period
    For each period, collect all stocks' ROA, EBIT/PPE, and forward_return values
    
    Args:
        data: List of stock data dictionaries
        
    Returns:
        Dictionary mapping period -> {'roa': [values], 'ebit_ppe': [values], 
                                      'forward_return_roa': [values], 'forward_return_ebit': [values]}
    """
    period_data = {}
    
    for stock in data:
        symbol = stock.get("symbol", "Unknown")
        for entry in stock.get("data", []):
            period = entry.get("period")
            roa = entry.get("roa")
            ebit_ppe = entry.get("ebit_ppe")
            forward_return = entry.get("forward_return")
            
            # Skip invalid periods (like 0 or None)
            if period is None or period == 0:
                continue
            
            # Initialize period if not exists
            if period not in period_data:
                period_data[period] = {"roa": [], "ebit_ppe": [], "forward_return_roa": [], "forward_return_ebit": []}
            
            # Add valid ROA data points
            if (roa is not None and forward_return is not None and 
                isinstance(roa, (int, float)) and isinstance(forward_return, (int, float))):
                period_data[period]["roa"].append(float(roa))
                period_data[period]["forward_return_roa"].append(float(forward_return))
            
            # Add valid EBIT/PPE data points
            if (ebit_ppe is not None and forward_return is not None and 
                isinstance(ebit_ppe, (int, float)) and isinstance(forward_return, (int, float))):
                period_data[period]["ebit_ppe"].append(float(ebit_ppe))
                period_data[period]["forward_return_ebit"].append(float(forward_return))
    
    return period_data

def calculate_correlations(metric_values: List[float], forward_return_values: List[float]) -> dict:
    """
    Calculate correlation statistics between a metric and forward return
    
    Args:
        metric_values: List of metric values (e.g., ROA or EBIT/PPE)
        forward_return_values: List of forward return values
        
    Returns:
        Dictionary with correlation statistics
    """
    
    if len(metric_values) < 2:
        return {
            "n_pairs": len(metric_values),
            "pearson_correlation": None,
            "pearson_pvalue": None,
            "ranked_correlation": None,
            "ranked_pvalue": None,
            "spearman_correlation": None,
            "spearman_pvalue": None,
            "error": "Insufficient data points for correlation"
        }
    
    # Convert to numpy arrays
    metric_array = np.array(metric_values)
    forward_return_array = np.array(forward_return_values)
    
    # Rank the data before correlating
    # Rankdata assigns ranks from 1 to n (where n = number of data points)
    # Average ranks are used for tied values
    metric_ranks = rankdata(metric_array, method='average')
    forward_return_ranks = rankdata(forward_return_array, method='average')
    
    # Calculate Pearson correlation on original values (linear relationship)
    pearson_corr, pearson_p = pearsonr(metric_array, forward_return_array)
    
    # Calculate correlation on ranked data (this is equivalent to Spearman)
    ranked_corr, ranked_p = pearsonr(metric_ranks, forward_return_ranks)
    
    # Also calculate Spearman for verification (should match ranked correlation)
    spearman_corr, spearman_p = spearmanr(metric_array, forward_return_array)
    
    # Calculate basic statistics
    metric_mean = np.mean(metric_array)
    metric_std = np.std(metric_array)
    forward_return_mean = np.mean(forward_return_array)
    forward_return_std = np.std(forward_return_array)
    
    return {
        "n_pairs": len(metric_values),
        "pearson_correlation": float(pearson_corr),
        "pearson_pvalue": float(pearson_p),
        "ranked_correlation": float(ranked_corr),
        "ranked_pvalue": float(ranked_p),
        "spearman_correlation": float(spearman_corr),
        "spearman_pvalue": float(spearman_p),
        "metric_mean": float(metric_mean),
        "metric_std": float(metric_std),
        "metric_min": float(np.min(metric_array)),
        "metric_max": float(np.max(metric_array)),
        "forward_return_mean": float(forward_return_mean),
        "forward_return_std": float(forward_return_std),
        "forward_return_min": float(np.min(forward_return_array)),
        "forward_return_max": float(np.max(forward_return_array))
    }

def print_statistics(stats: dict):
    """
    Print correlation statistics in a readable format
    
    Args:
        stats: Dictionary with correlation statistics
    """
    print("\n" + "="*80)
    print("ROA vs Forward Return Correlation Analysis")
    print("="*80)
    print(f"\nNumber of data points: {stats['n_pairs']:,}")
    print(f"\nROA Statistics:")
    print(f"  Mean: {stats['roa_mean']:.4f}")
    print(f"  Std Dev: {stats['roa_std']:.4f}")
    print(f"  Min: {stats['roa_min']:.4f}")
    print(f"  Max: {stats['roa_max']:.4f}")
    print(f"\nForward Return Statistics:")
    print(f"  Mean: {stats['forward_return_mean']:.2f}%")
    print(f"  Std Dev: {stats['forward_return_std']:.2f}%")
    print(f"  Min: {stats['forward_return_min']:.2f}%")
    print(f"  Max: {stats['forward_return_max']:.2f}%")
    print(f"\nCorrelation Results:")
    print(f"  Pearson Correlation (on original values): {stats['pearson_correlation']:.4f}")
    print(f"  Pearson p-value: {stats['pearson_pvalue']:.4e}")
    if stats['pearson_pvalue'] < 0.05:
        print(f"    -> Statistically significant (p < 0.05)")
    else:
        print(f"    -> Not statistically significant (p >= 0.05)")
    print(f"\n  Ranked Correlation (on ranked values): {stats['ranked_correlation']:.4f}")
    print(f"  Ranked p-value: {stats['ranked_pvalue']:.4e}")
    if stats['ranked_pvalue'] < 0.05:
        print(f"    -> Statistically significant (p < 0.05)")
    else:
        print(f"    -> Not statistically significant (p >= 0.05)")
    print(f"\n  Spearman Correlation (for verification): {stats['spearman_correlation']:.4f}")
    print(f"  Spearman p-value: {stats['spearman_pvalue']:.4e}")
    print(f"    -> Note: Ranked correlation should match Spearman correlation")
    print("\n" + "="*80)

def plot_ranks(roa_ranks: List[float], forward_return_ranks: List[float], 
               stats: dict, output_file: str = "roa_forward_return_ranks.png"):
    """
    Create a scatter plot of ranked ROA vs ranked forward return
    
    Args:
        roa_ranks: List of ROA ranks (1 to n)
        forward_return_ranks: List of forward return ranks (1 to n)
        stats: Dictionary with correlation statistics
        output_file: Output filename for the plot
    """
    plt.figure(figsize=(12, 8))
    
    # Create scatter plot
    plt.scatter(roa_ranks, forward_return_ranks, alpha=0.5, s=20)
    
    # Add labels and title
    plt.xlabel('ROA Rank (1 = lowest, ' + str(stats['n_pairs']) + ' = highest)', fontsize=12)
    plt.ylabel('Forward Return Rank (1 = lowest, ' + str(stats['n_pairs']) + ' = highest)', fontsize=12)
    plt.title('Ranked ROA vs Ranked Forward Return\n(All Stocks, All Periods)', fontsize=14, fontweight='bold')
    
    # Add correlation statistics as text
    stats_text = f"Ranked Correlation: {stats['ranked_correlation']:.4f}\n"
    stats_text += f"p-value: {stats['ranked_pvalue']:.4e}\n"
    stats_text += f"Number of data points: {stats['n_pairs']:,}\n"
    stats_text += f"Ranks range from 1 to {stats['n_pairs']}"
    
    plt.text(0.05, 0.95, stats_text, transform=plt.gca().transAxes,
             fontsize=10, verticalalignment='top',
             bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5))
    
    # Add diagonal reference line (perfect correlation would follow this)
    max_rank = stats['n_pairs']
    plt.plot([1, max_rank], [1, max_rank], 'r--', alpha=0.3, label='Perfect Correlation')
    plt.legend()
    
    # Set equal aspect ratio and limits
    plt.xlim(0, max_rank + 50)
    plt.ylim(0, max_rank + 50)
    plt.gca().set_aspect('equal', adjustable='box')
    
    # Add grid
    plt.grid(True, alpha=0.3)
    
    # Tight layout
    plt.tight_layout()
    
    # Save plot
    plt.savefig(output_file, dpi=300, bbox_inches='tight')
    print(f"\nPlot saved to {output_file}")
    
    # Show plot
    plt.show()

def print_period_correlations(roa_results: List[dict], ebit_ppe_results: List[dict]):
    """
    Print summary statistics for correlation results across all periods
    
    Args:
        roa_results: List of dictionaries with ROA correlation results
        ebit_ppe_results: List of dictionaries with EBIT/PPE correlation results
    """
    print("\n" + "="*100)
    print("ROA vs Forward Return Correlation Summary")
    print("="*100)
    
    roa_significant_count = 0
    roa_correlations = []
    roa_weights = []  # Number of data points for each period (for weighting)
    
    for result in roa_results:
        ranked_corr = result['ranked_correlation']
        p_value = result['ranked_pvalue']
        is_significant = p_value < 0.05 if p_value is not None else False
        
        if is_significant:
            roa_significant_count += 1
        if ranked_corr is not None:
            roa_correlations.append(ranked_corr)
            roa_weights.append(result['n_pairs'])  # Use number of data points as weight
    
    print("\nSummary Statistics Across All Periods:")
    print(f"  Total periods analyzed: {len(roa_results)}")
    print(f"  Periods with significant correlation (p < 0.05): {roa_significant_count}")
    if roa_correlations:
        # Calculate weighted average correlation (weighted by number of data points)
        correlations_array = np.array(roa_correlations)
        weights_array = np.array(roa_weights)
        weighted_avg = np.average(correlations_array, weights=weights_array)
        
        print(f"  Average ranked correlation (unweighted): {np.mean(roa_correlations):.4f}")
        print(f"  Weighted average ranked correlation (by data points): {weighted_avg:.4f}")
        print(f"  Median ranked correlation: {np.median(roa_correlations):.4f}")
        print(f"  Min ranked correlation: {np.min(roa_correlations):.4f}")
        print(f"  Max ranked correlation: {np.max(roa_correlations):.4f}")
    print("="*100)
    
    print("\n" + "="*100)
    print("EBIT/PPE vs Forward Return Correlation Summary")
    print("="*100)
    
    ebit_significant_count = 0
    ebit_correlations = []
    ebit_weights = []  # Number of data points for each period (for weighting)
    
    for result in ebit_ppe_results:
        ranked_corr = result['ranked_correlation']
        p_value = result['ranked_pvalue']
        is_significant = p_value < 0.05 if p_value is not None else False
        
        if is_significant:
            ebit_significant_count += 1
        if ranked_corr is not None:
            ebit_correlations.append(ranked_corr)
            ebit_weights.append(result['n_pairs'])  # Use number of data points as weight
    
    print("\nSummary Statistics Across All Periods:")
    print(f"  Total periods analyzed: {len(ebit_ppe_results)}")
    print(f"  Periods with significant correlation (p < 0.05): {ebit_significant_count}")
    if ebit_correlations:
        # Calculate weighted average correlation (weighted by number of data points)
        correlations_array = np.array(ebit_correlations)
        weights_array = np.array(ebit_weights)
        weighted_avg = np.average(correlations_array, weights=weights_array)
        
        print(f"  Average ranked correlation (unweighted): {np.mean(ebit_correlations):.4f}")
        print(f"  Weighted average ranked correlation (by data points): {weighted_avg:.4f}")
        print(f"  Median ranked correlation: {np.median(ebit_correlations):.4f}")
        print(f"  Min ranked correlation: {np.min(ebit_correlations):.4f}")
        print(f"  Max ranked correlation: {np.max(ebit_correlations):.4f}")
    print("="*100)

def main():
    """
    Main function to calculate and display ROA vs forward return correlation by period
    """
    print("Loading data from metrics.json...")
    data = load_data("metrics.json")
    
    if not data:
        print("No data loaded. Exiting.")
        return
    
    print(f"Loaded data for {len(data)} stock(s)")
    
    # Extract data grouped by period
    print("\nExtracting ROA, EBIT/PPE, and forward return data by period...")
    period_data = extract_data_by_period(data)
    
    print(f"Found {len(period_data)} unique periods")
    
    if len(period_data) == 0:
        print("No valid period data found. Exiting.")
        return
    
    # Calculate correlations for each period
    print("\nCalculating correlations for each period...")
    roa_results = []
    ebit_ppe_results = []
    
    # Sort periods for consistent output
    sorted_periods = sorted([p for p in period_data.keys() if isinstance(p, str) or (isinstance(p, (int, float)) and p != 0)])
    
    for period in sorted_periods:
        # Calculate ROA correlations
        roa_values = period_data[period]["roa"]
        forward_return_roa = period_data[period]["forward_return_roa"]
        
        if len(roa_values) >= 2 and len(roa_values) == len(forward_return_roa):
            stats = calculate_correlations(roa_values, forward_return_roa)
            stats['period'] = period
            roa_results.append(stats)
        
        # Calculate EBIT/PPE correlations
        ebit_ppe_values = period_data[period]["ebit_ppe"]
        forward_return_ebit = period_data[period]["forward_return_ebit"]
        
        if len(ebit_ppe_values) >= 2 and len(ebit_ppe_values) == len(forward_return_ebit):
            stats = calculate_correlations(ebit_ppe_values, forward_return_ebit)
            stats['period'] = period
            ebit_ppe_results.append(stats)
    
    # Print results by period
    print_period_correlations(roa_results, ebit_ppe_results)

if __name__ == "__main__":
    main()

